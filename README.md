# 记录自己学习《图解设计模式》这本书的全部过程
本书上传的所有代码都是可以运行的，在此附上本书源码地址： [http://www.ituring.com.cn/book/1811](http://www.ituring.com.cn/book/1811)<br/>
在此向本书作者和译者表示感谢

## 运行环境 ##
Eclipse版本：Oxygen.2 Release (4.7.2)<br/>
JDK版本：jdk1.7.0_79

## 代码结构 ##
![](https://i.imgur.com/9Aw7W7w.png)
<pre>
src\com\gdp
+---abstractFactory------------------------抽象工厂模式
+---adapter--------------------------------适配器模式
+---bridge---------------------------------桥接模式
+---builder--------------------------------建造者模式
+---chainOfResponsibility------------------职责链模式
+---command--------------------------------命令模式
+---composite------------------------------组合模式
+---decorator------------------------------装饰者模式
+---facade---------------------------------外观模式
+---factoryMethod--------------------------工厂模式
+---flyweight------------------------------享元模式
+---interpreter----------------------------解释器模式
+---iterator-------------------------------迭代模式
+---mediator-------------------------------中介者模式
+---memento--------------------------------备忘录模式
+---observer-------------------------------观察者模式
+---prototype------------------------------原型模式
+---proxy----------------------------------代理模式
+---singleton------------------------------单例模式
+---state----------------------------------状态转换模式
+---strategy-------------------------------策略模式
+---templateMethod-------------------------模版模式
+---visitor--------------------------------访问者模式
images-------------------------------------运行结果截图
static-------------------------------------程序中需要用到的静态资源（程序中已经写好读取路径）
</pre>

## 运行结果 ##
### 第一章-Iterator（迭代器）模式 ###
示例
![](https://i.imgur.com/GZDJh5C.png)
习题1-1
![](https://i.imgur.com/Nq2hL7h.png)
### 第二章-Adapter（适配器）模式 ###
使用继承的示例
![](https://i.imgur.com/ahVgADk.png)
使用委托的示例
![](https://i.imgur.com/pCAvtTW.png)
习题2-2：修改了适配器代码，可以打印出新的文件
![](https://i.imgur.com/T0EVo2q.png)
### 第三章-Template Method（模版）模式 ###
示例
![](https://i.imgur.com/a4RBk0q.png)
### 第四章-Factory Method（工厂）模式 ###
示例
![](https://i.imgur.com/3vSxlja.png)
习题4-2
![](https://i.imgur.com/QAAL7JE.png)
### 第五章-Singleton（单例）模式 ###
示例
![](https://i.imgur.com/yZkxsLr.png)
习题5-1
![](https://i.imgur.com/DnNUuDs.png)
习题5-2
![](https://i.imgur.com/NNf1nPE.png)
### 第六章-Prototype（原型）模式 ###
示例
![](https://i.imgur.com/qOx1ksd.png)
### 第七章-Builder（建造者）模式 ###
示例
![](https://i.imgur.com/hOd4EmM.png)
![](https://i.imgur.com/kdK1Ohr.png)
习题7-3
![](https://i.imgur.com/rryvFBD.png)
### 第八章-Abstract Factory（抽象工厂）模式 ###
示例
![](https://i.imgur.com/VbxLOLr.png)
![](https://i.imgur.com/LvNAC1U.png)
习题8-2
![](https://i.imgur.com/74xRtxg.png)
### 第九章-Bridge（桥接）模式 ###
示例
![](https://i.imgur.com/SsI28zo.png)
习题9-1
![](https://i.imgur.com/Yoj3NqL.png)
习题9-2
![](https://i.imgur.com/gfV2awX.png)
习题9-3
![](https://i.imgur.com/WAfS5c8.png)
### 第十章-Strategy（策略）模式 ###
示例
![](https://i.imgur.com/aojP8ZA.png)
习题10-1
![](https://i.imgur.com/pt1G8XV.png)
习题10-4
![](https://i.imgur.com/RrHLciB.png)
### 第十一章-Composite（组合）模式 ###
示例
![](https://i.imgur.com/mZaFfAA.png)
习题11-2
![](https://i.imgur.com/5EcfLrT.png)
### 第十二章-Decorator（装饰者）模式 ###
示例
![](https://i.imgur.com/jxpE6bR.png)
习题12-1
![](https://i.imgur.com/U0HOeRB.png)
习题12-2
![](https://i.imgur.com/qU8GsDe.png)
### 第十三-Visitor（访问者）模式 ###
示例
![](https://i.imgur.com/tyHsI0V.png)
习题13-1
![](https://i.imgur.com/G9rgbmB.png)
习题13-2
![](https://i.imgur.com/HAHddxC.png)
习题13-3
![](https://i.imgur.com/WfYc9yt.png)
### 第十四章-Chain of Responsibility（职责链）模式 ###
示例
![](https://i.imgur.com/ubbBbve.png)
习题14-4
![](https://i.imgur.com/p3m0Y6A.png)
### 第十五章-Facade（外观）模式 ###
示例
![](https://i.imgur.com/Yxl7JSB.png)
习题15-2
![](https://i.imgur.com/sd4yk6j.png)
### 第十六章-Mediator（中介者）模式 ###
示例
![](https://i.imgur.com/spkKhjx.png)
习题16-1
![](https://i.imgur.com/P94UWzp.png)
### 第十七章-Observer（观察者）模式 ###
示例
![](https://i.imgur.com/mi50jWR.png)
习题17-1
![](https://i.imgur.com/TqlwJgD.png)
习题17-2
![](https://i.imgur.com/6XAoCMd.png)
### 第十八章-Memento（备忘录）模式 ###
示例
![](https://i.imgur.com/9Ac57AY.png)
习题18-4
![](https://i.imgur.com/x1PatxD.png)
### 第十九章-State（状态转换）模式 ###
示例
![](https://i.imgur.com/xYndge7.png)
习题19-2
![](https://i.imgur.com/DFfxOVk.png)
习题19-3
![](https://i.imgur.com/5O2nLuS.png)
习题19-4
![](https://i.imgur.com/p5EBKF0.png)
### 第二十章-Flyweight（享元）模式 ###
示例
![](https://i.imgur.com/8gv7jZI.png)
习题20-1
![](https://i.imgur.com/RUkicYL.png)
习题20-2
![](https://i.imgur.com/GQJhN3z.png)
### 第二十一章-Proxy（代理）模式 ###
示例
![](https://i.imgur.com/KROINru.png)
习题21-1
![](https://i.imgur.com/IiSqwSO.png)
### 第二十二章-Command（命令）模式 ###
示例
![](https://i.imgur.com/x3k5ulV.png)
习题22-1
![](https://i.imgur.com/Z0lT12e.png)
习题22-2
![](https://i.imgur.com/BxHtsxL.png)
习题22-3
![](https://i.imgur.com/B03X4XA.png)
### 第二十三章-Interpreter（解释器）模式 ###
示例
![](https://i.imgur.com/8tB6AAA.png)
习题23-1
![](https://i.imgur.com/JMjpkVT.png)
## 总结 ##
1. Iterator模式：遍历与实现分离，遍历的时候不依赖实现。
2. Adapter模式：版本升级和兼容性，现有的类已经被测试过，创建一个新类来适配，只需要测试新类，如果出现了Bug，可以很容易的知道问题所在。
3. Template Method模式：在父类中定义处理流程的框架，在子类中实现具体处理，避开使用instanceof指定子类。
4. Factory Method模式：框架与具体加工分离。
5. Singleton模式：获取唯一一个实例（延迟加载，同步机制）。
6. Prototype模式：根据实例（实例原型、实例模型）来生成新实例。
7. Builder模式：可替换性，可以替换Builder组件类。
8. Abstract Factory模式：易于增加具体工厂，难以增加新的零件。
9. Bridge模式：将类的功能层次和实现层次分开。继承是强关联，委托是弱关联。
10. Strategy模式：使用委托这种弱关联关系可以很方便地整体替换算法。
11. Composite模式：容器和内容具有一致性，并且可以创建出递归结构。
12. Decorator模式：不修改被装饰的类即可增加功能，缺点是会导致程序中增加许多功能类似的很小的类
13. Visitor模式：双重分发，将处理从数据结构中分离出来。缺点是将来对数据结构的改良就会变得非常困难。
14. Chain of Responsibility模式：弱化了发出请求的人和处理请求的人之间的关系，缺点是导致处理请求发生了延迟。
15. Facade模式：优点是接口(API)变少了，程序与外部的关联关系弱化了。
16. Mediator模式：不让互相关联的对象之间进行任何直接的通信，而是让它们向仲裁者进行报告。
17. Observer模式：将对象的状态变化通知给其他对象。
18. Memento模式：具有SRP(单一权责)，记录和保存对象的当前状态。
19. State模式：分而治之，缺点是每个ConcreateState角色都需要知道娶她ConcreateState角色。
20. Flyweight模式：共享实例减少内存使用量，线程池或者各种缓存技术（Memcached，Redis）。
21. Proxy模式：Virtual Proxy（虚拟代理：真正需要实例时才生成和初始化实例），Remote Proxy（远程代理：RMI），Access Proxy（访问限制：CAS）
22. Command模式：用对象表示 “ 命令 ”来保存命令历史记录和重复执行命令。
23. Interpreter模式：使用BNF递归定义语言的方法和推导语法树。

## 心得 ##
1. 这些模式都是对接口或者抽象类编程，关于如何选择接口或者抽象类主要是（1）如果想支持并设计模版，可以用抽象类来实现。（2）如果想实现多重继承，那么你必须使用接口。（3）如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。
2. 本书中对模式的分类也十分合理：（1）适应设计模式：Iterator，Adapter；（2）交给子类：Template Method，Factory Method；（3）生成实例：Singleton，Prototype，Builder，Abstract Factory；（4）分开考虑：Bridge，Strategy；（5）一致性：Composite，Decorator；（6）访问数据结构：Visitor，Chain of Responsibility；（7）简单化：Facade，Mediator；（8）管理状态：Observer，Memento，State；（9）避免浪费：Flyweight，Proxy；（10）用类来表现：Command，Interpreter。通过对各种模式的特性分类，而GOF中的分类总是让人有点记不住。
3. 有空想用Interpreter模式(Java版本)来实现Lisp的解释器，可参考Build-Your-Own-Lisp，GitHub地址：[https://github.com/orangeduck/BuildYourOwnLisp](https://github.com/orangeduck/BuildYourOwnLisp)，目前有一个不全的中文翻译版本，GitHub地址如下：[https://github.com/ksco/BuildYourOwnLispCn](https://github.com/ksco/BuildYourOwnLispCn)，笔者已经联系了该文译者，有幸参与该书剩下几章内容的翻译。完成之后经过译者同意会发布出来。